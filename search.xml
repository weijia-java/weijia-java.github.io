<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySQL-03 | 事务隔离：为什么你改了我还看不见？</title>
      <link href="2021/01/02/MySQL-03-%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%A0%E6%94%B9%E4%BA%86%E6%88%91%E8%BF%98%E7%9C%8B%E4%B8%8D%E8%A7%81%EF%BC%9F/"/>
      <url>2021/01/02/MySQL-03-%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%A0%E6%94%B9%E4%BA%86%E6%88%91%E8%BF%98%E7%9C%8B%E4%B8%8D%E8%A7%81%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>提到MySQL数据库的读写操作，就必不可免的会想到事务，而MySQL数据库本身是没有事务功能的，事务不是所有的引擎都支持的。比如MySQL原生的<em>MyISAM不支持事务</em>。</p><p>而事务就是用来保证一次事务的操作中，要么事务中的操作全部成功，要么全部失败，这也是保证了数据库的安全。</p><h2 id="隔离性和隔离级别"><a href="#隔离性和隔离级别" class="headerlink" title="隔离性和隔离级别"></a>隔离性和隔离级别</h2><p>提到事务，伴随的肯定有ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性），下面就来详细解答一下“隔离性”。</p><p>当数据库上有多个事务同时执行的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题，为了解决这些问题，就有了“隔离界别”的概念。</p><p>SQL标准的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）。可重复读（repeatable read）和串行化（serializable）。</p><ul><li>读未提交：事务A没提交时，事务A的变更后的数据也可以被其它事务查看（select）。</li><li>读提交：事务A只有在提交之后，事务A的变更后的数据才可以被其它事务查看（select）。<ul><li>读提交的情况下，每一次select查询都会重新生成一个视图</li></ul></li><li>可重复读：事务A在执行过程中查看到的数据永远是它第一次select到的数据，在可重复读的隔离级别下，只有在提交事务之后，其它事务才可以查看。<ul><li>可重复读下是在<em>第一次select</em>的时候生成视图，且永远使用这个视图</li><li>可重复读下，普通读是<strong>快照读</strong>，当其他事务执行了<code>insert，delete</code>并提交之后，当前事务下执行读取是<strong>当前读</strong>。</li></ul></li><li>串行化：“写”加锁，“读”加锁。当出现读写锁冲突时，后访问的事务必须等前一个事务执行完成。</li></ul><p>其中“读提交”和“可重复读”可以用下面的例子来说明。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table T(c int) engine&#x3D;InnoDB;</span><br><span class="line">mysql&gt; insert into T(c) values(1);</span><br></pre></td></tr></table></figure><img src="https://static001.geekbang.org/resource/image/7d/f8/7dea45932a6b722eb069d2264d0066f8.png" class="lazyload" data-srcset="https://static001.geekbang.org/resource/image/7d/f8/7dea45932a6b722eb069d2264d0066f8.png" srcset="data:image/png;base64,666" style="zoom:50%;" /><p>在不同隔离级别的情况下，事务A会存在不同的返回结果，V1,V2和V3的返回值不同：</p><ul><li>读未提交：v1=2、v2=v3=2。</li><li>读提交：v1=1、v2=v3=2.</li><li>可重复读：v1=1、v2=1，v3=2.</li><li>串行化：事务B在执行“将1改为2”时会被锁住，一直到事务A提交事务之后才会执行。V1=1、V2=1、V3=2。</li></ul><p>在不同的隔离级别下，数据库行为是不相同的。Oracle数据库的默认隔离级别是“读提交”，因此对于一些从Oracle迁移到MySQL的应用，为保证数据库隔离级别的一致，将MySQL的隔离级别设置为“读提交”。</p><table><thead><tr><th align="center">修改隔离级别SQL</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">set global transaction isolation level 隔离级别</td><td align="center">设置全局事务隔离级别</td></tr><tr><td align="center">set session transaction isolation level 隔离级别</td><td align="center">设置当前会话的事务隔离级别</td></tr><tr><td align="center">set transaction isolation level 隔离级别</td><td align="center">设置下一次事务的事务隔离级别</td></tr></tbody></table><p>利用<code>show variables like &#39;transaction_isolation&#39;;</code>来查看当前事务隔离级别。</p><h2 id="事务隔离级别的实现"><a href="#事务隔离级别的实现" class="headerlink" title="事务隔离级别的实现"></a>事务隔离级别的实现</h2><p>在MySQL中，实际上每条记录在更新的时候都会同时记录一条回滚操作，记录上的最新值，通过回滚操作，都可以得到前一个状态的值。</p><ul><li>除了记录变更记录，还会记录一条变更相反的回滚操作记录，前者记录在<code>redo log</code>，后者记录在<code>undo log</code></li><li>在长事务中，会存在很长的回滚日志，read-view存在很久，导致日志很长占用大量的存储空间。</li><li>回滚日志会删除当前最老的read-view之前的记录，也就是说系统会判断，当没有事务需要用到这些回滚日志时，回滚日志会被删除。</li><li>在MySQL5.5及之前的版本，回滚日志是跟数据字典一起放在ibdata文件里的，即使长事务最终提交，回滚段被清理，文件也不会小。</li></ul><p>假设一个值从1被顺序更改为2、3、4，在回滚日志里面就会有类似下面的记录。</p><img src="https://static001.geekbang.org/resource/image/d9/ee/d9c313809e5ac148fc39feff532f0fee.png" class="lazyload" data-srcset="https://static001.geekbang.org/resource/image/d9/ee/d9c313809e5ac148fc39feff532f0fee.png" srcset="data:image/png;base64,666" style="zoom:50%;" /><h2 id="事务的启动方式"><a href="#事务的启动方式" class="headerlink" title="事务的启动方式"></a>事务的启动方式</h2><p>由于长事务存在潜在的风险，建议尽量避免使用长事务。事务的启动方式有下面几种：</p><ol><li>显示启动事务语句，<code>begin</code>或<code>start-transaction</code>，配套的提交语句是<code>commit</code>，回滚语句是<code>rollback</code>。</li><li><code>set autocommit=0</code>，将这个线程的自动提交关掉。意味着只执行一个<code>select</code>语句，这个事务就启动了，而且不会自动提交。这个事务持续存在直到你主动执行<code>commit</code>或<code>rollback</code>语句，或者断开连接。</li></ol><p>为了避免长连接导致的长事务，建议使用<code>set autocommit=1</code>和通过显示语句的方式来启动事务。</p><p>当然为了避免多个事务之间需要多一次交互的问题，建议使用<code>commit work and chain</code></p><p>在 autocommit 为 1 的情况下，用 begin 显式启动的事务，如果执行 commit 则提交事务。如果执行 <code>commit work and chain</code>，则是提交事务并自动启动下一个事务，这样也省去了再次执行 begin 语句的开销。同时带来的好处是从程序开发的角度明确地知道每个语句是否处于事务中。</p><p>使用下面的SQL语句来查询长事务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))&gt;60</span><br><span class="line">-- 查找时间超过60s的事务</span><br></pre></td></tr></table></figure><ul><li>information_schema库的innodb_trx查询长事务。</li></ul><h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><p>在开发过程中，尽可能的减小事务范围，少用长事务，如果无法避免，保证逻辑日志空间足够用，并且支持动态日志空间增长。监控innodb_trx表，发现长事务报警。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL-02 | 日志系统：一条SQL更新语句是如何执行的？</title>
      <link href="2020/12/28/02-%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%EF%BC%9A%E4%B8%80%E6%9D%A1SQL%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84%EF%BC%9F/"/>
      <url>2020/12/28/02-%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%EF%BC%9A%E4%B8%80%E6%9D%A1SQL%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table T(ID int primary key, c int);</span><br><span class="line">mysql&gt; update T set c&#x3D;c+1 where ID&#x3D;2;</span><br></pre></td></tr></table></figure><ol><li><p>先走一遍查询SQL语句的流程，拿到数据行。</p></li><li><p>执行更新，然后利用引擎接口把数据更新到内存中，同时将这次更新操作记录到redo log中，此时redo log相应数据状态处于prepare状态。</p></li><li><p>执行器生成这个操作的binlog，并把binlog写入磁盘。</p></li><li><p>执行器调用引擎的提交事务接口，并把redo log中的相应数据的prepare改为commit，更新完成。</p><p><em>注：更新完成后，redo log里记录的操作是在一个合适的时间再写入数据库磁盘中。</em></p><img src="https://static001.geekbang.org/resource/image/2e/be/2e5bff4910ec189fe1ee6e2ecc7b4bbe.png" class="lazyload" data-srcset="https://static001.geekbang.org/resource/image/2e/be/2e5bff4910ec189fe1ee6e2ecc7b4bbe.png" srcset="data:image/png;base64,666" style="zoom:50%;" /></li></ol><h2 id="redo-log：重做日志"><a href="#redo-log：重做日志" class="headerlink" title="redo log：重做日志"></a>redo log：重做日志</h2><ul><li><p>什么是重做日志文件redo log？</p><p>假设在一个酒馆中，酒馆老板有一块粉板，专门用来记录客人的赊账记录。如果赊账的人不多，那么他可以把顾客姓名和账目写在板上。但如果赊账的人多了，粉板总会有记不下的时候，这个时候掌柜一定还有一个专门记录赊账的账本。</p><p>如果有人要赊账或还账的话，一般有两种做法：</p><ul><li><p>直接把账本翻出来，把这次赊的帐加上去或者扣除掉。</p></li><li><p>另外一种，先把这次的帐记录在粉板上，等打样或者粉板写满之后再把账本翻出来核算。</p></li></ul><p>在生意红火柜台很忙的时候，一般会选择后者。如果在很忙的时候使用第一种做法，那么你需要去拿出账本，翻找还账的顾客名，然后进行还账或者赊账操作。每次都需要翻找顾客名，效率极低。</p></li><li><p>redo log的存储结构。</p><p>在InnoDB中，redo log 的大小是固定的，比如可以配置一组4个文件，每个文件大小1GB，一个4GB。4个文件是使用循环队列结构，从头开始写，写到末尾就又回到开头循环写。</p><img src="https://static001.geekbang.org/resource/image/16/a7/16a7950217b3f0f4ed02db5db59562a7.png" class="lazyload" data-srcset="https://static001.geekbang.org/resource/image/16/a7/16a7950217b3f0f4ed02db5db59562a7.png" srcset="data:image/png;base64,666" style="zoom:50%;" /><p>write pos是当前记录的位置，一边写一边后移，写到第3号文件末尾后就回到0号文件开头、checkpoint是当前要擦除的位置，也是往后推移并且循环的，擦除记录之前要把记录更新到数据文件。</p><p>write pos和checkpoint直接空白位置是“粉板”空余部分，可以用来记录更新操作。如果write pos追上checkpoint表示“粉板”满了。这时候就不能执行更新了，需要先擦除一些记录。</p><p>注：redo log是<em>顺序写入</em>的。</p></li><li><p>redo log的作用。</p><p>有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为<strong>crash-safe</strong>。</p><p><strong>注：由于redo log主要是记录的还没有写道数据文件的更新记录，所以当数据库异常重启的时候直接把redo log中的数据更新到数据库中就行。不会造成数据丢失。</strong></p></li></ul><h2 id="binlog：归档日志"><a href="#binlog：归档日志" class="headerlink" title="binlog：归档日志"></a>binlog：归档日志</h2><ul><li><p>为什么存在两个日志？</p><p>因为最开始MySQL里并没有InnoDB引擎。自带引擎是MyISAM，但是MyISAM没有crash-safe的能力，binlog日志只能用于归档。而InnoDB是另一个公司以插件的形式引入MySQL的，既然只能只依靠binlog没有crash-safe能力，所以InnoDB使用另外一套日志系统，也就是redo log实现crash-safe。</p></li><li><p>两种日志的区别：</p><ol><li><p>redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用。</p></li><li><p>redo log是物理日志，记录的是“<strong>某个数据页上做了什么修改</strong>”；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如直接<strong>记录SQL语句</strong>或者直接<strong>记录更新前的数据+更新后的数据</strong>。</p></li><li><p>redo log是<strong>循环写</strong>的，空间固定会用完；binlog是<strong>追加写</strong>入的。“追加写”是指binlog文件写到一定大小后会切换到下一个文件继续写，并不会覆盖以前的日志。</p></li><li><p>redo log是在物理磁盘上是<strong>顺序写</strong>的；而binlog是并不是。</p></li></ol></li></ul><h2 id="更新：两段式提交"><a href="#更新：两段式提交" class="headerlink" title="更新：两段式提交"></a>更新：两段式提交</h2><ol><li><p>执行器首先找引擎取ID=2这一行。ID是主键。如果ID=2这一行所在数据页本来就在内存中，就直接返回給执行器；否则，需要先从磁盘读入内存，然后返回。</p></li><li><p>执行器拿到行数据，把值加1，得到新一行的数据，在调用引擎接口写入这行新数据。</p></li><li><p>引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log中，此时redo log相应记录处于prepare状态，然后告知执行器执行完成了，随时可以提交事务（还未提交事务）。</p></li><li><p>执行器生成操作的binlog，并把binlog写入磁盘。</p></li><li><p>执行器调用引擎接口提交事务，引擎把刚刚写入到redo log相应数据状态改为commit，更新完成。</p></li></ol>  <img src="https://static001.geekbang.org/resource/image/2e/be/2e5bff4910ec189fe1ee6e2ecc7b4bbe.png" class="lazyload" data-srcset="https://static001.geekbang.org/resource/image/2e/be/2e5bff4910ec189fe1ee6e2ecc7b4bbe.png" srcset="data:image/png;base64,666" style="zoom:50%;" /><p>而上图中两段式提交，是为了让两份日志保持逻辑一致。而保持一致性也就是为了：<strong>怎样让数据库恢复到半个月内任意一秒的状态？</strong></p><p>如果DBA承诺说半个月可以恢复，那么备份系统中一定有近半个月所有的binlog，同时系统在半个月内定期一次全备份。</p><p>当系统需要恢复的指定的时间时：</p><ul><li>首先，找到最近一次的全备份，然后利用binlog找到全备份到现在执行的产生的binlog，来恢复剩余数据。</li></ul><p>好了，说完了数据恢复过程，我们回来说说，为什么日志需要“两阶段提交”。这里不妨用反证法来进行解释。</p><p>由于redo log和binlog是两个独立的逻辑，如果不用两段式提交，那么就先写完redo log再写binlog，或者反过来我们看看会出现什么问题。</p><p>仍然用前面的 update 语句来做例子。假设当前 ID=2 的行，字段 c 的值是 0，再假设执行 update 语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了 crash，会出现什么情况呢？</p><ol><li><strong>先写redo log后写binlog：</strong>假设redo log写完binlog未写完，MySQL异常重启，这个时候c的值是1，由于binlog没写完就crash，这个时候binlog并没有这条记录的修改，如果使用binlog来进行同步或者备份恢复的话，那么恢复的数据c值就为0，这就造成了与原库的值不同。</li><li><strong>先写binlog后写redo log：</strong>在binlog写完之后就异常重启，由于redo log还没有写，则重启后恢复的c值为0，而binlog中已经有了这条修改，则在同步和恢复库时就会存在c值为1，与原库不同。</li></ol><p>可以看到，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。</p><p><strong>注：如果在两段式提交中redo log写完，状态为prepare，binlog也写完，commit之前异常重启，则在恢复的时候由于redo log为prepare状态binlog中也存在该数据，则执行器会自动提交该事务。</strong></p><h2 id="注"><a href="#注" class="headerlink" title="注"></a>注</h2><ul><li>redo log 用于保证 crash-safe 能力。<code>innodb_flush_log_at_trx_commit</code> 这个参数设置成 1 的时候，表示每次事务的 redo log 都直接持久化到磁盘。这个参数我建议你设置成 1，这样可以保证 MySQL 异常重启之后数据不丢失。</li><li><code>sync_binlog </code>这个参数设置成 1 的时候，表示每次事务的 binlog 都持久化到磁盘。这个参数我也建议你设置成 1，这样可以保证 MySQL 异常重启之后 binlog 不丢失。</li><li>binlog是可以关闭的所以单独有binlog是不可靠的。</li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> redo log </tag>
            
            <tag> binlog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL-01 | 基础架构：一条SQL查询语句是如何执行的？</title>
      <link href="2020/12/24/MYSQL-01%20%20%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%EF%BC%9A%E4%B8%80%E6%9D%A1SQL%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84%EF%BC%9F/"/>
      <url>2020/12/24/MYSQL-01%20%20%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%EF%BC%9A%E4%B8%80%E6%9D%A1SQL%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL-01-基础架构：一条SQL查询语句是如何执行的？"><a href="#MySQL-01-基础架构：一条SQL查询语句是如何执行的？" class="headerlink" title="MySQL-01 | 基础架构：一条SQL查询语句是如何执行的？"></a>MySQL-01 | 基础架构：一条SQL查询语句是如何执行的？</h1><h2 id="0-MySQL慢查询"><a href="#0-MySQL慢查询" class="headerlink" title="0 MySQL慢查询"></a>0 MySQL慢查询</h2><p>​        在web开发如此火爆的年代，数据库就成了我们开发中必不可少的一环。而使用数据库的绝大部分的时间是在单一的查询数据可，在大量的数据库查询中我们要尽可能的减少每一条的查询时间，而慢查询日志，就可以让我们在发现查询时间过长的SQL语句的时候对于查询为什么这么慢有很大帮助。</p><p>​        下面是MySQL<strong>慢查询日志：（一次性，永久的要修改my文件）</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-- 查看慢查询日志是否打开</span><br><span class="line">show variables like &#39;%slow%&#39; ;</span><br><span class="line"></span><br><span class="line">-- 查看慢查询状态</span><br><span class="line">show global status like &#39;%slow%&#39;;</span><br><span class="line"> </span><br><span class="line">-- 打开慢查询日志</span><br><span class="line">set  @@global.slow_query_log &#x3D; ON;</span><br><span class="line"> </span><br><span class="line">-- 睡10s 测试慢查询</span><br><span class="line">select sleep(5) ;</span><br><span class="line"> </span><br><span class="line">-- 查看慢查询超时时间</span><br><span class="line">show variables like &#39;long_query%&#39;</span><br><span class="line"></span><br><span class="line">-- 设置慢查询时间，超过这个时间则记录入慢查询日志</span><br><span class="line">set long_query_time&#x3D;2</span><br><span class="line"></span><br><span class="line">-- 查看慢查询日志输出方式</span><br><span class="line">select @@global.log_output </span><br><span class="line"> </span><br><span class="line">-- 设置慢查询日志 table形式表示</span><br><span class="line">set @@global.log_output&#x3D;&#39;TABLE&#39;;</span><br><span class="line"> </span><br><span class="line">-- 查询慢查询日志</span><br><span class="line">select * from mysql.slow_log; </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1-基本结构"><a href="#1-基本结构" class="headerlink" title="1 基本结构"></a>1 基本结构</h2><p>​        写这篇文章主要是想梳理一下MYSQL在执行一条SQL语句的时候发生的各种情况，MYSQL自己是怎么处理的。比如更新一条信息，根据（没有）主键查询信息。在以上的古城中数据库是怎样处理一下连带问题（权限，缓存，一致性，脏读和幻读的问题）。</p><p>​        </p><p>​        在MYSQL中一共可以大致的分成两层（不包括客户端）<strong>server层和存储引擎</strong>，而MYSQL的SQL语句主要是在<strong>server</strong>层进行处理。</p><img src="https://static001.geekbang.org/resource/image/0d/d9/0d2070e8f84c4801adbfa03bda1f98d9.png" class="lazyload" data-srcset="https://static001.geekbang.org/resource/image/0d/d9/0d2070e8f84c4801adbfa03bda1f98d9.png" srcset="data:image/png;base64,666" alt="MYSQL基本零件" style="zoom: 33%;" align="middle" /><p>​        在上图的可以看出，基本上分为server层和存储引擎两个部分。</p><p>​        server层包括连接器、查询缓存（在8.0之后删除了）、分析器、优化器和执行器等，几乎包揽了MYSQL所有<strong>重要的核心功能，以及所有的内置函数。</strong>所有跨存储引擎的功能都在这一层实现，比如存储过程。触发器、视图等。</p><p>​        存储引擎负责<strong>数据的提取和存储</strong>功能。其架构是插件式（可更换），支持InnoDB、MyISAM、Memory等多个存储引擎，在MySQL5.5.5版本开始默认InnoDB（在创建标时可以使用<code>engine=Memory</code>来使用你想要的存储引擎）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from T where ID&#x3D;10；</span><br></pre></td></tr></table></figure><p>​        下面开始简单的解释一下上面的语句的执行流程。</p><h2 id="2-连接器"><a href="#2-连接器" class="headerlink" title="2 连接器"></a>2 连接器</h2><p>​        在MySQL执行上面的数据前，首先要创建一个链接，来连接数据库，这个时候就是连接器来起作用。连接器主要负责和用户<strong>建立链接，获取权限，维持和管理连接</strong>。连接命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MySQL-h$ip -P$port -u$user -p -- 参数依次是数据库ip地址、端口号、用户名、密码</span><br></pre></td></tr></table></figure><p>​        连接命令中的mysql是客户端工具，用来和服务端建立连接。在完成经典的TCP三次握手后，连接器开始验证身份。</p><ul><li><p>如果用户名或密码错误，收到一个<code>ACCESS DENIED FOR USER</code> 的错误。</p></li><li><p>如果验证通过，<strong>连接器首先会去权限表查找你当前用户所持有的权限。之后的所有操作都依赖与这一次的权限查询</strong>。这也就意味着在当前连接没断开或者重新连接之前，管理员怎么修改当前用户的权限都不会起到效果，修改权限之后，只有在<em>下一次连接时才会生效</em></p><p>连接完成后如，如果你没有后续的动作，这个连接就处于空闲状态，你可以使用<code>show processlist</code>命令看到它，其中<code>sleep</code>表示连接在空闲状态</p></li></ul><p><img src="https://static001.geekbang.org/resource/image/f2/ed/f2da4aa3a672d48ec05df97b9f992fed.png" class="lazyload" data-srcset="https://static001.geekbang.org/resource/image/f2/ed/f2da4aa3a672d48ec05df97b9f992fed.png" srcset="data:image/png;base64,666"></p><p>​        如果空闲时间超过<code>wait_timeout</code>(最大空闲时间，默认值8小时)，自动断开连接。当断开连接后再去查询操作会返回<code>LOST CONNECTION TO MYSQL SERVER DURING QUERY</code> , 这时间你就需要重新连接，在执行当前请求了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#39;wait_timeout&#39;;</span><br></pre></td></tr></table></figure><h3 id="长短连接"><a href="#长短连接" class="headerlink" title="长短连接"></a>长短连接</h3><p>​        数据库中，长连接是连接成功后，执行几个请求后，还继续长时间保持这个连接，下一个请求继续使用。短连接是连接成功后，在执行几个查询之后就断开连接，下一个查询新建一个连接。</p><p>​        由于数据库中建立连接的过程非常浪费时间，所以建议使用长连接，减少短连接的使用。但由于大量使用长连接有时候会导致MySQL占用内存会越来越快，这是因为MySQL在执行过程中使用的内存是管理在连接对象里面的，这些资源会在连接断开的时候释放。长连接积累下来，导致内存占用过大，被系统前置杀掉（OOM），从现象看就是MySQL异常重启。</p><p>​        解决上面的问题你可以用以下的两种方案：</p><ol><li>定期断开长连接。使用一段时间，或者程序里面判断一个占用内存过比较大的操作后，断开连接，之后查询重连。</li><li>在MySQL5.7或之后的版本中，你可以每次执行一个比较大的操作后使用<code>mysql_reset_connection</code>来初始化连接资源。这个过程不需要重连和重新做权限验证，但可以恢复到连接刚刚建立时的状态。</li></ol><h2 id="3-查询缓存"><a href="#3-查询缓存" class="headerlink" title="3 查询缓存"></a>3 查询缓存</h2><p>​        在连接上服务端之后，我们就来到了查询缓存。MySQL拿到一个查询语句后，先查询缓存中是否崔在。MySQL会把之前执行的SQL语句和结果以<strong>key-value</strong>对的形式直接<strong>缓存到内存中</strong>。key是之前查询的整个SQL语句，而value是查询结果。若果缓存命中直接返回给客户端。</p><p>​        如果未命中，则继续后面的分析，优化和执行阶段，执行结果会保存到缓存中。</p><p>​        <em>但大多数情况下建议不要使用缓存，因为缓存命中率极低，并且还要占据内存。</em></p><p>​        查询缓存的命中率非常低，只要一个表进行了更新操作，这个表上的所有查询缓存都会被清空。因此可能刚刚把上一条执行结果缓存进去，马上该表就发生了更新导致缓存丢失。对于一个更新压力大的数据库，查询缓存命中率极低。除非你是一个静态表或者更新操作极少的表（系统配置表）。</p><p>​        MySQL提供了按照需要是否使用缓存。可以将参数<code>query_cache_type</code>设置成<code>DEMAND</code>，这种模式下SQL语句不会使用查询缓存。对于使用查询缓存的语句，可以使用<code>SQL_CACHE</code>显示指定。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select SQL_CACHE * from T where ID&#x3D;10；</span><br></pre></td></tr></table></figure><p>​        <strong>注：查询缓存在 MySQL8.0 版本直接删除了，没有查询缓存这个功能了。</strong></p><p>​        <strong>注：查询缓存命中返回结果前，会进行权限查询，判断当前用户是否有对这个表操作的权限。</strong></p><p>​        </p><h2 id="4-分析器"><a href="#4-分析器" class="headerlink" title="4 分析器"></a>4 分析器</h2><p>​        如果没有命中查询缓存，就开始真正的执行语句了。首先MySQL需要知道你要做什么，因此需要对SQL语句进行<strong>“词法分析”</strong>。你输入的是由多个字符串和空格组成的SQL语句，MySQL需要识别出里面的字符串的含义。</p><p>​        MySQL从你输入的“<code>SELECT</code>”关键字识别出，这是一个查询语句。它也要把字符串“T”识别成“表名T”，把字符串“ID”识别成“列ID”。</p><p>​        做完这些识别后，还要做的就是语法分析。根据上面词法分析的结果，语法分析会语法规则，判断你输入的这个SQL语句是否满足MySQL语法。如果语句错误，会给你返回<code>YOU HAVE AN ERROR IN YOU SQL SYNTAX</code>的错误提醒，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; elect * from t where ID&#x3D;1;</span><br><span class="line"></span><br><span class="line">ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;elect * from t where ID&#x3D;1&#39; at line 1</span><br></pre></td></tr></table></figure><h2 id="5-优化器"><a href="#5-优化器" class="headerlink" title="5 优化器"></a>5 优化器</h2><p>​        经过了分析器，MySQL就知道你要做什么了。在开始执行之前，还要经过优化器的处理。</p><p>​        优化器是在表里面有多个索引的时候，决定使用哪个索引，或者在一个语句有多表关联的时候，决定各个表的连接顺序。比如你执行下面这样的语句，这个语句是执行两个表的join：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t1 join t2 using(ID)  where t1.c&#x3D;10 and t2.d&#x3D;20;</span><br></pre></td></tr></table></figure><ul><li>既可以先从t1里面取出c=10的记录ID值，在根据ID值关联到t2，再判断t2里面的d是否等于20。</li><li>也可以先从t2里面取出d=20的记录ID值，再根据ID值关联到t1，再判断t1里面的c是否等于10。</li></ul><p>​        两种执行方法的结果一样，但执行所需要的时间是不同的，而优化器的作用就是决定使用哪一个方案。优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。</p><h2 id="6-执行器"><a href="#6-执行器" class="headerlink" title="6 执行器"></a>6 执行器</h2><p>​        开始执行的时候要判断当前用户是否对这个表拥有权限，如果没有则返回无权限错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from T where ID&#x3D;10;</span><br><span class="line"></span><br><span class="line">ERROR 1142 (42000): SELECT command denied to user &#39;b&#39;@&#39;localhost&#39; for table &#39;T&#39;</span><br></pre></td></tr></table></figure><p>​        有权限，就打开表继续执行。打开表的时候执行器会根据引擎定义，去使用引擎提供的接口。</p><p>​        在无索引的情况下会一行一行的进行对比查找结果，存在索引的情况下，会在索引树上一层一层的进行对比。</p><h2 id="7-注"><a href="#7-注" class="headerlink" title="7 注"></a>7 注</h2><p>如果表中没有字段K，而你执行了这个语句<code>select * from T where k=1</code>肯定会报错：“Unknown column k in where clause”，这个错误是在<strong>分析器</strong>上给出的。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>My New Post</title>
      <link href="2020/12/22/My-New-Post/"/>
      <url>2020/12/22/My-New-Post/</url>
      
        <content type="html"><![CDATA[<h2 id="Hexo文章初步建设"><a href="#Hexo文章初步建设" class="headerlink" title="Hexo文章初步建设"></a>Hexo文章初步建设</h2><ol><li><p>新建文章命令 <code>hexo new post postname</code> </p><p>文章生成目录存在于blog/scourse/</p><p>win、IOS系统使用markdown软件打开编辑，命令行使用vim</p></li><li><p>文章生成 <code>hexo g</code></p></li><li><p>文章发布 <code>hexo d</code></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2020/12/22/hello-world/"/>
      <url>2020/12/22/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
