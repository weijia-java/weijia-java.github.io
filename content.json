{"meta":{"title":"初白的BLOG","subtitle":"","description":"","author":"John Doe","url":"http://weijia-java.github.io","root":"/"},"pages":[{"title":"categories","date":"2020-12-23T15:09:29.000Z","updated":"2020-12-23T15:10:28.154Z","comments":true,"path":"categories/index.html","permalink":"http://weijia-java.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"MySQL-04 | 索引的前世今生：为什么索引内加快查询速度？","slug":"MySQL-04-索引前世今生：为什么索引可以加快查询速度？","date":"2021-01-16T06:12:25.000Z","updated":"2021-01-16T12:30:37.749Z","comments":true,"path":"2021/01/16/MySQL-04-索引前世今生：为什么索引可以加快查询速度？/","link":"","permalink":"http://weijia-java.github.io/2021/01/16/MySQL-04-%E7%B4%A2%E5%BC%95%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E7%B4%A2%E5%BC%95%E5%8F%AF%E4%BB%A5%E5%8A%A0%E5%BF%AB%E6%9F%A5%E8%AF%A2%E9%80%9F%E5%BA%A6%EF%BC%9F/","excerpt":"","text":"提到数据库优化，我们第一个想到的是数据库索引。但什么是索引，索引又是如何工作的呢？ 索引的出现其实就是为了提高数据查询的效率，就像新华词典的目录一样。在一本新华词典中，在几百页中，如何快速的找到你想要查询的那个字，如果没有目录的情况下我想浪费很多时间。同样情况下数据库的索引就像一本书的目录一样。 索引的常见模型可以提高读写效率的数据结构很多，并不只有哈希表这一种数据模型，还存在有序数据和搜索树。 哈希表：Key-value键值对存储数据的结构，输入key获取相应的value值。哈希的思路很简单，把值放在数组里，用一个哈希函数把key换成一个确定的位置，然后把value放在数组的这个位置。 不可避免的，有多个key经过哈希函数的换算，会出现在同一个位置造成冲突。处理这种情况下，用拉链法处理冲突。 哈希表这种结构只适用于等值查询的场景 有序数组：将数据以递增的方式存入到一个数组中。 由于是数组结构，按顺序插入到数组中，导致每一次的插入都需要移动数据，时间也就不可避免的浪费。 数组数序存入，在范围查询的条件下，有很大的优势。 有序数组索引只适用于静态存储引擎 二叉搜索树：父节点左子树所有结点的值小于父节点的值，右子树所有结点的值大于父节点的值。查找的时间复杂度为O（log（n））。 为了维持O(log(n))的查询复杂度，需要保持为平衡二叉树。 树可以有二叉，也可以有多叉。多叉树存在多个儿子，儿子之间的大小保证从左到右递增。 变为多叉树也是为了减少访问磁盘的次数。 在MySQL中，索引是在存储引擎层实现的，不同存储引擎的索引的工作方式并不一样。 InnoDB的索引模型在InnoDB中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。而InnoDB使用了B+树索引模型，所以数据都是存储在B+树中。 每一个索引在InnoDB中对应一颗B+树。 每一个索引树都占有物理内存（合理创建索引，避免索引比数据文件还大） 每一次更新数据都需要维护索引。 假设，有一个主键列为ID的表，表中字段K，并且K上存在索引。 12345mysql&gt; create table T(id int primary key, k int not null, name varchar(16),index (k))engine&#x3D;InnoDB; 表中R1-R5的（ID,K）值分别为（100，1）、（200，2）、（300，3）、（500，5）和（600，6），两棵树的如下： 从图中不难看出，根据叶子节点的内容，索引类型分为主键索引和非主键索引。 主键索引的叶子节点存的是整行数据。在InnoDB里，主键索引也被称为聚簇索引 非主键索引的叶子节点内容是主键的值。在InnoDB里，非主键索引也被称为二级索引 主键索引和普通索引的查询有什么区别？ 如果语句是select * from T where ID＝500，只需要搜索ID这个B+树。 如果语句是select * from T where k＝5，先搜索K索引树，得到ID的值为500，再到ID索引树搜索一次。这个过程为回表。 非主键索引的查询需要多扫描一颗索引树。因此，我们在应用中应该尽量使用主键索引。 索引维护B+树为了维护索引有序性，在插入新值的时候需要做必要的维护。以上图为例，如果插入新的行ID值为700，则只需要在R5的记录后面插入一个新纪录。如果新插入的ID值为400，就麻烦了，需要逻辑上挪动后面的数据，空出位置。 更糟糕的是，如果R5所在的数据页已经满了，根据B+树的算法，这个时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为分裂。 除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整个空间利用率降低大约50%。 有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。 建议使用自增主键（逻辑主键），避免造成数据的分裂和合并操作。 在只有唯一索引的时候可以使用业务主键。 索引相关概念下面为索引相关的列子： 12345678mysql&gt; create table T (ID int primary key,k int NOT NULL DEFAULT 0, s varchar(16) NOT NULL DEFAULT &#39;&#39;,index k(k))engine&#x3D;InnoDB;insert into T values(100,1, &#39;aa&#39;),(200,2,&#39;bb&#39;),(300,3,&#39;cc&#39;),(500,5,&#39;ee&#39;),(600,6,&#39;ff&#39;),(700,7,&#39;gg&#39;); 如果无执行select * from T where k between 3 and 5，需要执行回表两次，读取k索引树3条记录。 执行过程如下： 在k索引树上找到k＝3的记录，取得id＝300。 再到ID索引树查到ID＝300对应的R3。 在k索引树取下一个值k＝5，取得ID＝500。 再回到ID索引树查到ID＝500对应的R4。 在k索引树取下一个值k＝6，不满足条件，循环结束。 在这个例子中，由于查询结果所需要的数据只有主键索引上有，所以不得不回表。可以使用索引覆盖来减少回表。 索引覆盖如果执行select ID from T where k between 3 and 5，这时只需要返回ID的值，而ID的值已经在k的索引树上了，因此可以直接提供查询结果，不需要回表。这个查询里，索引k已经“覆盖了”我们的查询需求，我们称为覆盖索引。 在一个市民信息表上，是否有必要将身份证号和名字建立联合索引 假设市民表定义是这样的： 12345678910CREATE TABLE &#96;tuser&#96; ( &#96;id&#96; int(11) NOT NULL, &#96;id_card&#96; varchar(32) DEFAULT NULL, &#96;name&#96; varchar(32) DEFAULT NULL, &#96;age&#96; int(11) DEFAULT NULL, &#96;ismale&#96; tinyint(1) DEFAULT NULL, PRIMARY KEY (&#96;id&#96;), KEY &#96;id_card&#96; (&#96;id_card&#96;), KEY &#96;name_age&#96; (&#96;name&#96;,&#96;age&#96;)) ENGINE&#x3D;InnoDB 身份证号是市民的唯一标识，也就是说，如果有根据身份证号查询市民信息打的需求，我们只要在身份证号上建立索引就够了。而再建立一个（身份证号，姓名）的联合索引，很浪费空间。 如果现在有一个高频请求，需要根据市民的身份证号查询他的姓名，这个联合索引就有意义，可以使用覆盖索引，减少回表。 最左前缀原则B+树这种索引结构，可以利用索引的“最左前缀”，来定位记录。 为了直观说明这个概念，使用（name，age）这个联合索引分析。 可以看出，索引项是按照索引定义里面出现的字段顺序排序的。 查询张三时，可以快速定位到ID4，然后向后遍历得到所有需要的结果。 第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。 第二原则是，考虑的原则是空间。比如上面这个市民表的情况，name字段比age字段大的，那建议创建一个（name，age）的联合索引和一个（age）的单字段索引。 索引下推以市民表的联合索引（name，age）为例。如果现在有一个需求：检索出表中“名字第一个字是张，而且年龄是十岁的所有男孩”。那么SQL语句如下： 1mysql&gt; select * from tuser where name like &#39;张%&#39; and age&#x3D;10 and ismale&#x3D;1; 这个语句在搜索索引树的时候，只能用“张%”，找到第一个满足条件的记录ID3。 而 MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。","categories":[{"name":"MySQL解析","slug":"MySQL解析","permalink":"http://weijia-java.github.io/categories/MySQL%E8%A7%A3%E6%9E%90/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://weijia-java.github.io/tags/MySQL/"},{"name":"索引","slug":"索引","permalink":"http://weijia-java.github.io/tags/%E7%B4%A2%E5%BC%95/"}]},{"title":"秒杀 01 | 做好动静分离","slug":"秒杀-01-做好动静分离","date":"2021-01-09T06:12:40.000Z","updated":"2021-01-09T07:07:23.990Z","comments":true,"path":"2021/01/09/秒杀-01-做好动静分离/","link":"","permalink":"http://weijia-java.github.io/2021/01/09/%E7%A7%92%E6%9D%80-01-%E5%81%9A%E5%A5%BD%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB/","excerpt":"","text":"秒杀对于系统的要求秒杀场景中，对于系统的要求其实就是：快、准、稳。 而快就是要求系统响应速度要快，而这就在于减少请求的数据量和减少一些没有必要的请求。 而动静分离就是只对于一些必要的信息数据进行刷新请求，而一些长久不变的数据本地化或者更新时不做请求。 动静分离就是把用户请求的数据（如HTML页面）划分为“动态数据”和“静态数据”。 主要区别就是看页面中输出的数据是否和URL、浏览者、时间、低于相关。以及是否含有Cookie等私密数据。 怎么做静态数据缓存？ 把静态数据缓存到离用户最近的地方：用户浏览器里、CDN或服务端的cache中。 静态化改造就是直接缓存HTTP链接：在第一次http请求之后，将整个链接作为key，链接响应的页面作为value，缓存到cache中（减少生成一个页面在服务器中的请求）。 决定让谁来进行缓存，因为java中servlet对http解析较慢，所以可以把http请求缓存在web服务器上。 如何做动静分离改造 URL唯一化：将商品详情系统中对于详情页面的请求的URL可以做到唯一，每个商品由ID来标识，那么http://item.xxx.com/item.htm?id=xxxxxx就可以作为唯一的URL标识（key），组装好的页面作为value。 分离浏览者相关因素：而对于判断用户是否登录，登录身份这个随时都有可能发生变化的因素我们可以通过动态请求获取。 分离时间因素：服务端输出的时间也通过动态获取（不能用本地时间，因为可修改）。 异步化地域因素：地域商品推荐或者一个地域化差异信息可以通过动态获取。 去掉cookie：服务端输出的页面包含的cookie可以通过代码软件删除，知识将服务端cache中的页面cookie删除，客户端的页面cookie照样存在。 两种动态能容处理方案： ESI：在web代理服务上做动态内容请求，并将请求插入到静态页面中，用户直接拿到一个完整的页面。用户体验好，对服务器性能有影响。 CSI：动态能容由客户端单独发送一个异步请求获取，在客户端组装，对服务器良好，用户体验差。 动静分离几种架构方案 实体机单机部署 统一Cache层 上CDN 实体单机部署将虚拟机改为实体机，以增大Cache容量，采用一致性Hash分组的方式来提升命中率。Cache分组越少命中率越高，缺点会使单个商品集中在一个分组中，容易导致Cache被击穿，分组不能太少也不能太多。 优点在于无网络瓶颈，能够使用大内存，提升命中率。 统一Cache层单独将Cache统一分离出来，形成一个单独的Cache集群：将Cache单独拿出来统一管理可以减少运维成本，方便接入其他静态化系统，可以最大化的利用内存，不同系统之间的内存可以动态切换。 缺点：Cache层内部交换存在网络瓶颈，挂掉一台会影响很大一部分缓存数据。 CDN存在的问题： 失效问题：上CDN就要保证CDN可以在秒级内，让分布在全国世界各地的Cache同时失效。 命中率问题：放在全国的CDN上必导致Cache分散，就会导致命中率降低。 发布更新问题：发布系统必须足够简洁高效，而且还要考虑快速回滚和排查问题的简便性。 优化办法： 靠近访问量比较集中地区使用cache。 离主站较远的地区。 节点到主站间的网络比较好，而且稳定。 节点内容比较大，不会占用其他CDN太多的资源。 节点不易太多。 考虑使用CDN的二级Cache比较合适，因为二级Cache数量少，容量大，让用户先请求CDN的二级Cache中，没命中会源站点获取数据。","categories":[{"name":"秒杀","slug":"秒杀","permalink":"http://weijia-java.github.io/categories/%E7%A7%92%E6%9D%80/"}],"tags":[{"name":"动静分离","slug":"动静分离","permalink":"http://weijia-java.github.io/tags/%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB/"}]},{"title":"MySQL-03 | 事务隔离：为什么你改了我还看不见？","slug":"MySQL-03-事务隔离：为什么你改了我还看不见？","date":"2021-01-02T08:04:44.000Z","updated":"2021-01-03T02:27:18.104Z","comments":true,"path":"2021/01/02/MySQL-03-事务隔离：为什么你改了我还看不见？/","link":"","permalink":"http://weijia-java.github.io/2021/01/02/MySQL-03-%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%A0%E6%94%B9%E4%BA%86%E6%88%91%E8%BF%98%E7%9C%8B%E4%B8%8D%E8%A7%81%EF%BC%9F/","excerpt":"","text":"提到MySQL数据库的读写操作，就必不可免的会想到事务，而MySQL数据库本身是没有事务功能的，事务不是所有的引擎都支持的。比如MySQL原生的MyISAM不支持事务。 而事务就是用来保证一次事务的操作中，要么事务中的操作全部成功，要么全部失败，这也是保证了数据库的安全。 隔离性和隔离级别提到事务，伴随的肯定有ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性），下面就来详细解答一下“隔离性”。 当数据库上有多个事务同时执行的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题，为了解决这些问题，就有了“隔离界别”的概念。 SQL标准的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）。可重复读（repeatable read）和串行化（serializable）。 读未提交：事务A没提交时，事务A的变更后的数据也可以被其它事务查看（select）。 读提交：事务A只有在提交之后，事务A的变更后的数据才可以被其它事务查看（select）。 读提交的情况下，每一次select查询都会重新生成一个视图 可重复读：事务A在执行过程中查看到的数据永远是它第一次select到的数据，在可重复读的隔离级别下，只有在提交事务之后，其它事务才可以查看。 可重复读下是在第一次select的时候生成视图，且永远使用这个视图 可重复读下，普通读是快照读，当其他事务执行了insert，delete并提交之后，当前事务下执行读取是当前读。 串行化：“写”加锁，“读”加锁。当出现读写锁冲突时，后访问的事务必须等前一个事务执行完成。 其中“读提交”和“可重复读”可以用下面的例子来说明。 12mysql&gt; create table T(c int) engine&#x3D;InnoDB;mysql&gt; insert into T(c) values(1); 在不同隔离级别的情况下，事务A会存在不同的返回结果，V1,V2和V3的返回值不同： 读未提交：v1=2、v2=v3=2。 读提交：v1=1、v2=v3=2. 可重复读：v1=1、v2=1，v3=2. 串行化：事务B在执行“将1改为2”时会被锁住，一直到事务A提交事务之后才会执行。V1=1、V2=1、V3=2。 在不同的隔离级别下，数据库行为是不相同的。Oracle数据库的默认隔离级别是“读提交”，因此对于一些从Oracle迁移到MySQL的应用，为保证数据库隔离级别的一致，将MySQL的隔离级别设置为“读提交”。 修改隔离级别SQL 说明 set global transaction isolation level 隔离级别 设置全局事务隔离级别 set session transaction isolation level 隔离级别 设置当前会话的事务隔离级别 set transaction isolation level 隔离级别 设置下一次事务的事务隔离级别 利用show variables like &#39;transaction_isolation&#39;;来查看当前事务隔离级别。 事务隔离级别的实现在MySQL中，实际上每条记录在更新的时候都会同时记录一条回滚操作，记录上的最新值，通过回滚操作，都可以得到前一个状态的值。 除了记录变更记录，还会记录一条变更相反的回滚操作记录，前者记录在redo log，后者记录在undo log 在长事务中，会存在很长的回滚日志，read-view存在很久，导致日志很长占用大量的存储空间。 回滚日志会删除当前最老的read-view之前的记录，也就是说系统会判断，当没有事务需要用到这些回滚日志时，回滚日志会被删除。 在MySQL5.5及之前的版本，回滚日志是跟数据字典一起放在ibdata文件里的，即使长事务最终提交，回滚段被清理，文件也不会小。 假设一个值从1被顺序更改为2、3、4，在回滚日志里面就会有类似下面的记录。 事务的启动方式由于长事务存在潜在的风险，建议尽量避免使用长事务。事务的启动方式有下面几种： 显示启动事务语句，begin或start-transaction，配套的提交语句是commit，回滚语句是rollback。 set autocommit=0，将这个线程的自动提交关掉。意味着只执行一个select语句，这个事务就启动了，而且不会自动提交。这个事务持续存在直到你主动执行commit或rollback语句，或者断开连接。 为了避免长连接导致的长事务，建议使用set autocommit=1和通过显示语句的方式来启动事务。 当然为了避免多个事务之间需要多一次交互的问题，建议使用commit work and chain 在 autocommit 为 1 的情况下，用 begin 显式启动的事务，如果执行 commit 则提交事务。如果执行 commit work and chain，则是提交事务并自动启动下一个事务，这样也省去了再次执行 begin 语句的开销。同时带来的好处是从程序开发的角度明确地知道每个语句是否处于事务中。 使用下面的SQL语句来查询长事务： 12select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))&gt;60-- 查找时间超过60s的事务 information_schema库的innodb_trx查询长事务。 建议在开发过程中，尽可能的减小事务范围，少用长事务，如果无法避免，保证逻辑日志空间足够用，并且支持动态日志空间增长。监控innodb_trx表，发现长事务报警。","categories":[{"name":"MySQL解析","slug":"MySQL解析","permalink":"http://weijia-java.github.io/categories/MySQL%E8%A7%A3%E6%9E%90/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://weijia-java.github.io/tags/MySQL/"},{"name":"事务","slug":"事务","permalink":"http://weijia-java.github.io/tags/%E4%BA%8B%E5%8A%A1/"},{"name":"undo log","slug":"undo-log","permalink":"http://weijia-java.github.io/tags/undo-log/"}]},{"title":"MySQL-02 | 日志系统：一条SQL更新语句是如何执行的？","slug":"02-日志系统：一条SQL更新语句是如何执行的？","date":"2020-12-28T09:28:09.000Z","updated":"2021-01-03T01:35:18.621Z","comments":true,"path":"2020/12/28/02-日志系统：一条SQL更新语句是如何执行的？/","link":"","permalink":"http://weijia-java.github.io/2020/12/28/02-%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%EF%BC%9A%E4%B8%80%E6%9D%A1SQL%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84%EF%BC%9F/","excerpt":"","text":"12mysql&gt; create table T(ID int primary key, c int);mysql&gt; update T set c&#x3D;c+1 where ID&#x3D;2; 先走一遍查询SQL语句的流程，拿到数据行。 执行更新，然后利用引擎接口把数据更新到内存中，同时将这次更新操作记录到redo log中，此时redo log相应数据状态处于prepare状态。 执行器生成这个操作的binlog，并把binlog写入磁盘。 执行器调用引擎的提交事务接口，并把redo log中的相应数据的prepare改为commit，更新完成。 注：更新完成后，redo log里记录的操作是在一个合适的时间再写入数据库磁盘中。 redo log：重做日志 什么是重做日志文件redo log？ 假设在一个酒馆中，酒馆老板有一块粉板，专门用来记录客人的赊账记录。如果赊账的人不多，那么他可以把顾客姓名和账目写在板上。但如果赊账的人多了，粉板总会有记不下的时候，这个时候掌柜一定还有一个专门记录赊账的账本。 如果有人要赊账或还账的话，一般有两种做法： 直接把账本翻出来，把这次赊的帐加上去或者扣除掉。 另外一种，先把这次的帐记录在粉板上，等打样或者粉板写满之后再把账本翻出来核算。 在生意红火柜台很忙的时候，一般会选择后者。如果在很忙的时候使用第一种做法，那么你需要去拿出账本，翻找还账的顾客名，然后进行还账或者赊账操作。每次都需要翻找顾客名，效率极低。 redo log的存储结构。 在InnoDB中，redo log 的大小是固定的，比如可以配置一组4个文件，每个文件大小1GB，一个4GB。4个文件是使用循环队列结构，从头开始写，写到末尾就又回到开头循环写。 write pos是当前记录的位置，一边写一边后移，写到第3号文件末尾后就回到0号文件开头、checkpoint是当前要擦除的位置，也是往后推移并且循环的，擦除记录之前要把记录更新到数据文件。 write pos和checkpoint直接空白位置是“粉板”空余部分，可以用来记录更新操作。如果write pos追上checkpoint表示“粉板”满了。这时候就不能执行更新了，需要先擦除一些记录。 注：redo log是顺序写入的。 redo log的作用。 有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为crash-safe。 注：由于redo log主要是记录的还没有写道数据文件的更新记录，所以当数据库异常重启的时候直接把redo log中的数据更新到数据库中就行。不会造成数据丢失。 binlog：归档日志 为什么存在两个日志？ 因为最开始MySQL里并没有InnoDB引擎。自带引擎是MyISAM，但是MyISAM没有crash-safe的能力，binlog日志只能用于归档。而InnoDB是另一个公司以插件的形式引入MySQL的，既然只能只依靠binlog没有crash-safe能力，所以InnoDB使用另外一套日志系统，也就是redo log实现crash-safe。 两种日志的区别： redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用。 redo log是物理日志，记录的是“某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如直接记录SQL语句或者直接记录更新前的数据+更新后的数据。 redo log是循环写的，空间固定会用完；binlog是追加写入的。“追加写”是指binlog文件写到一定大小后会切换到下一个文件继续写，并不会覆盖以前的日志。 redo log是在物理磁盘上是顺序写的；而binlog是并不是。 更新：两段式提交 执行器首先找引擎取ID=2这一行。ID是主键。如果ID=2这一行所在数据页本来就在内存中，就直接返回給执行器；否则，需要先从磁盘读入内存，然后返回。 执行器拿到行数据，把值加1，得到新一行的数据，在调用引擎接口写入这行新数据。 引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log中，此时redo log相应记录处于prepare状态，然后告知执行器执行完成了，随时可以提交事务（还未提交事务）。 执行器生成操作的binlog，并把binlog写入磁盘。 执行器调用引擎接口提交事务，引擎把刚刚写入到redo log相应数据状态改为commit，更新完成。 而上图中两段式提交，是为了让两份日志保持逻辑一致。而保持一致性也就是为了：怎样让数据库恢复到半个月内任意一秒的状态？ 如果DBA承诺说半个月可以恢复，那么备份系统中一定有近半个月所有的binlog，同时系统在半个月内定期一次全备份。 当系统需要恢复的指定的时间时： 首先，找到最近一次的全备份，然后利用binlog找到全备份到现在执行的产生的binlog，来恢复剩余数据。 好了，说完了数据恢复过程，我们回来说说，为什么日志需要“两阶段提交”。这里不妨用反证法来进行解释。 由于redo log和binlog是两个独立的逻辑，如果不用两段式提交，那么就先写完redo log再写binlog，或者反过来我们看看会出现什么问题。 仍然用前面的 update 语句来做例子。假设当前 ID=2 的行，字段 c 的值是 0，再假设执行 update 语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了 crash，会出现什么情况呢？ 先写redo log后写binlog：假设redo log写完binlog未写完，MySQL异常重启，这个时候c的值是1，由于binlog没写完就crash，这个时候binlog并没有这条记录的修改，如果使用binlog来进行同步或者备份恢复的话，那么恢复的数据c值就为0，这就造成了与原库的值不同。 先写binlog后写redo log：在binlog写完之后就异常重启，由于redo log还没有写，则重启后恢复的c值为0，而binlog中已经有了这条修改，则在同步和恢复库时就会存在c值为1，与原库不同。 可以看到，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。 注：如果在两段式提交中redo log写完，状态为prepare，binlog也写完，commit之前异常重启，则在恢复的时候由于redo log为prepare状态binlog中也存在该数据，则执行器会自动提交该事务。 注 redo log 用于保证 crash-safe 能力。innodb_flush_log_at_trx_commit 这个参数设置成 1 的时候，表示每次事务的 redo log 都直接持久化到磁盘。这个参数我建议你设置成 1，这样可以保证 MySQL 异常重启之后数据不丢失。 sync_binlog 这个参数设置成 1 的时候，表示每次事务的 binlog 都持久化到磁盘。这个参数我也建议你设置成 1，这样可以保证 MySQL 异常重启之后 binlog 不丢失。 binlog是可以关闭的所以单独有binlog是不可靠的。","categories":[{"name":"MySQL解析","slug":"MySQL解析","permalink":"http://weijia-java.github.io/categories/MySQL%E8%A7%A3%E6%9E%90/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://weijia-java.github.io/tags/MySQL/"},{"name":"redo log","slug":"redo-log","permalink":"http://weijia-java.github.io/tags/redo-log/"},{"name":"binlog","slug":"binlog","permalink":"http://weijia-java.github.io/tags/binlog/"}]},{"title":"MySQL-01 | 基础架构：一条SQL查询语句是如何执行的？","slug":"MYSQL-01  基础架构：一条SQL查询语句是如何执行的？","date":"2020-12-24T09:48:39.000Z","updated":"2021-01-03T01:35:09.845Z","comments":true,"path":"2020/12/24/MYSQL-01  基础架构：一条SQL查询语句是如何执行的？/","link":"","permalink":"http://weijia-java.github.io/2020/12/24/MYSQL-01%20%20%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%EF%BC%9A%E4%B8%80%E6%9D%A1SQL%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84%EF%BC%9F/","excerpt":"","text":"MySQL-01 | 基础架构：一条SQL查询语句是如何执行的？0 MySQL慢查询​ 在web开发如此火爆的年代，数据库就成了我们开发中必不可少的一环。而使用数据库的绝大部分的时间是在单一的查询数据可，在大量的数据库查询中我们要尽可能的减少每一条的查询时间，而慢查询日志，就可以让我们在发现查询时间过长的SQL语句的时候对于查询为什么这么慢有很大帮助。 ​ 下面是MySQL慢查询日志：（一次性，永久的要修改my文件） 1234567891011121314151617181920212223242526272829-- 查看慢查询日志是否打开show variables like &#39;%slow%&#39; ;-- 查看慢查询状态show global status like &#39;%slow%&#39;; -- 打开慢查询日志set @@global.slow_query_log &#x3D; ON; -- 睡10s 测试慢查询select sleep(5) ; -- 查看慢查询超时时间show variables like &#39;long_query%&#39;-- 设置慢查询时间，超过这个时间则记录入慢查询日志set long_query_time&#x3D;2-- 查看慢查询日志输出方式select @@global.log_output -- 设置慢查询日志 table形式表示set @@global.log_output&#x3D;&#39;TABLE&#39;; -- 查询慢查询日志select * from mysql.slow_log; 1 基本结构​ 写这篇文章主要是想梳理一下MYSQL在执行一条SQL语句的时候发生的各种情况，MYSQL自己是怎么处理的。比如更新一条信息，根据（没有）主键查询信息。在以上的古城中数据库是怎样处理一下连带问题（权限，缓存，一致性，脏读和幻读的问题）。 ​ ​ 在MYSQL中一共可以大致的分成两层（不包括客户端）server层和存储引擎，而MYSQL的SQL语句主要是在server层进行处理。 ​ 在上图的可以看出，基本上分为server层和存储引擎两个部分。 ​ server层包括连接器、查询缓存（在8.0之后删除了）、分析器、优化器和执行器等，几乎包揽了MYSQL所有重要的核心功能，以及所有的内置函数。所有跨存储引擎的功能都在这一层实现，比如存储过程。触发器、视图等。 ​ 存储引擎负责数据的提取和存储功能。其架构是插件式（可更换），支持InnoDB、MyISAM、Memory等多个存储引擎，在MySQL5.5.5版本开始默认InnoDB（在创建标时可以使用engine=Memory来使用你想要的存储引擎）。 1mysql&gt; select * from T where ID&#x3D;10； ​ 下面开始简单的解释一下上面的语句的执行流程。 2 连接器​ 在MySQL执行上面的数据前，首先要创建一个链接，来连接数据库，这个时候就是连接器来起作用。连接器主要负责和用户建立链接，获取权限，维持和管理连接。连接命令如下： 1MySQL-h$ip -P$port -u$user -p -- 参数依次是数据库ip地址、端口号、用户名、密码 ​ 连接命令中的mysql是客户端工具，用来和服务端建立连接。在完成经典的TCP三次握手后，连接器开始验证身份。 如果用户名或密码错误，收到一个ACCESS DENIED FOR USER 的错误。 如果验证通过，连接器首先会去权限表查找你当前用户所持有的权限。之后的所有操作都依赖与这一次的权限查询。这也就意味着在当前连接没断开或者重新连接之前，管理员怎么修改当前用户的权限都不会起到效果，修改权限之后，只有在下一次连接时才会生效 连接完成后如，如果你没有后续的动作，这个连接就处于空闲状态，你可以使用show processlist命令看到它，其中sleep表示连接在空闲状态 ​ 如果空闲时间超过wait_timeout(最大空闲时间，默认值8小时)，自动断开连接。当断开连接后再去查询操作会返回LOST CONNECTION TO MYSQL SERVER DURING QUERY , 这时间你就需要重新连接，在执行当前请求了。 1mysql&gt; show variables like &#39;wait_timeout&#39;; 长短连接​ 数据库中，长连接是连接成功后，执行几个请求后，还继续长时间保持这个连接，下一个请求继续使用。短连接是连接成功后，在执行几个查询之后就断开连接，下一个查询新建一个连接。 ​ 由于数据库中建立连接的过程非常浪费时间，所以建议使用长连接，减少短连接的使用。但由于大量使用长连接有时候会导致MySQL占用内存会越来越快，这是因为MySQL在执行过程中使用的内存是管理在连接对象里面的，这些资源会在连接断开的时候释放。长连接积累下来，导致内存占用过大，被系统前置杀掉（OOM），从现象看就是MySQL异常重启。 ​ 解决上面的问题你可以用以下的两种方案： 定期断开长连接。使用一段时间，或者程序里面判断一个占用内存过比较大的操作后，断开连接，之后查询重连。 在MySQL5.7或之后的版本中，你可以每次执行一个比较大的操作后使用mysql_reset_connection来初始化连接资源。这个过程不需要重连和重新做权限验证，但可以恢复到连接刚刚建立时的状态。 3 查询缓存​ 在连接上服务端之后，我们就来到了查询缓存。MySQL拿到一个查询语句后，先查询缓存中是否崔在。MySQL会把之前执行的SQL语句和结果以key-value对的形式直接缓存到内存中。key是之前查询的整个SQL语句，而value是查询结果。若果缓存命中直接返回给客户端。 ​ 如果未命中，则继续后面的分析，优化和执行阶段，执行结果会保存到缓存中。 ​ 但大多数情况下建议不要使用缓存，因为缓存命中率极低，并且还要占据内存。 ​ 查询缓存的命中率非常低，只要一个表进行了更新操作，这个表上的所有查询缓存都会被清空。因此可能刚刚把上一条执行结果缓存进去，马上该表就发生了更新导致缓存丢失。对于一个更新压力大的数据库，查询缓存命中率极低。除非你是一个静态表或者更新操作极少的表（系统配置表）。 ​ MySQL提供了按照需要是否使用缓存。可以将参数query_cache_type设置成DEMAND，这种模式下SQL语句不会使用查询缓存。对于使用查询缓存的语句，可以使用SQL_CACHE显示指定。如下： 1mysql&gt; select SQL_CACHE * from T where ID&#x3D;10； ​ 注：查询缓存在 MySQL8.0 版本直接删除了，没有查询缓存这个功能了。 ​ 注：查询缓存命中返回结果前，会进行权限查询，判断当前用户是否有对这个表操作的权限。 ​ 4 分析器​ 如果没有命中查询缓存，就开始真正的执行语句了。首先MySQL需要知道你要做什么，因此需要对SQL语句进行“词法分析”。你输入的是由多个字符串和空格组成的SQL语句，MySQL需要识别出里面的字符串的含义。 ​ MySQL从你输入的“SELECT”关键字识别出，这是一个查询语句。它也要把字符串“T”识别成“表名T”，把字符串“ID”识别成“列ID”。 ​ 做完这些识别后，还要做的就是语法分析。根据上面词法分析的结果，语法分析会语法规则，判断你输入的这个SQL语句是否满足MySQL语法。如果语句错误，会给你返回YOU HAVE AN ERROR IN YOU SQL SYNTAX的错误提醒，如下： 1234mysql&gt; elect * from t where ID&#x3D;1;ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;elect * from t where ID&#x3D;1&#39; at line 1 5 优化器​ 经过了分析器，MySQL就知道你要做什么了。在开始执行之前，还要经过优化器的处理。 ​ 优化器是在表里面有多个索引的时候，决定使用哪个索引，或者在一个语句有多表关联的时候，决定各个表的连接顺序。比如你执行下面这样的语句，这个语句是执行两个表的join： 1mysql&gt; select * from t1 join t2 using(ID) where t1.c&#x3D;10 and t2.d&#x3D;20; 既可以先从t1里面取出c=10的记录ID值，在根据ID值关联到t2，再判断t2里面的d是否等于20。 也可以先从t2里面取出d=20的记录ID值，再根据ID值关联到t1，再判断t1里面的c是否等于10。 ​ 两种执行方法的结果一样，但执行所需要的时间是不同的，而优化器的作用就是决定使用哪一个方案。优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。 6 执行器​ 开始执行的时候要判断当前用户是否对这个表拥有权限，如果没有则返回无权限错误。 123mysql&gt; select * from T where ID&#x3D;10;ERROR 1142 (42000): SELECT command denied to user &#39;b&#39;@&#39;localhost&#39; for table &#39;T&#39; ​ 有权限，就打开表继续执行。打开表的时候执行器会根据引擎定义，去使用引擎提供的接口。 ​ 在无索引的情况下会一行一行的进行对比查找结果，存在索引的情况下，会在索引树上一层一层的进行对比。 7 注如果表中没有字段K，而你执行了这个语句select * from T where k=1肯定会报错：“Unknown column k in where clause”，这个错误是在分析器上给出的。","categories":[{"name":"MySQL解析","slug":"MySQL解析","permalink":"http://weijia-java.github.io/categories/MySQL%E8%A7%A3%E6%9E%90/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://weijia-java.github.io/tags/MySQL/"}]},{"title":"My New Post","slug":"My-New-Post","date":"2020-12-22T12:41:26.000Z","updated":"2020-12-24T03:03:09.176Z","comments":true,"path":"2020/12/22/My-New-Post/","link":"","permalink":"http://weijia-java.github.io/2020/12/22/My-New-Post/","excerpt":"","text":"Hexo文章初步建设 新建文章命令 hexo new post postname 文章生成目录存在于blog/scourse/ win、IOS系统使用markdown软件打开编辑，命令行使用vim 文章生成 hexo g 文章发布 hexo d","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://weijia-java.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://weijia-java.github.io/tags/Hexo/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-12-22T10:22:36.215Z","updated":"2020-12-22T10:22:36.215Z","comments":true,"path":"2020/12/22/hello-world/","link":"","permalink":"http://weijia-java.github.io/2020/12/22/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"MySQL解析","slug":"MySQL解析","permalink":"http://weijia-java.github.io/categories/MySQL%E8%A7%A3%E6%9E%90/"},{"name":"秒杀","slug":"秒杀","permalink":"http://weijia-java.github.io/categories/%E7%A7%92%E6%9D%80/"},{"name":"Hexo","slug":"Hexo","permalink":"http://weijia-java.github.io/categories/Hexo/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://weijia-java.github.io/tags/MySQL/"},{"name":"索引","slug":"索引","permalink":"http://weijia-java.github.io/tags/%E7%B4%A2%E5%BC%95/"},{"name":"动静分离","slug":"动静分离","permalink":"http://weijia-java.github.io/tags/%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB/"},{"name":"事务","slug":"事务","permalink":"http://weijia-java.github.io/tags/%E4%BA%8B%E5%8A%A1/"},{"name":"undo log","slug":"undo-log","permalink":"http://weijia-java.github.io/tags/undo-log/"},{"name":"redo log","slug":"redo-log","permalink":"http://weijia-java.github.io/tags/redo-log/"},{"name":"binlog","slug":"binlog","permalink":"http://weijia-java.github.io/tags/binlog/"},{"name":"Hexo","slug":"Hexo","permalink":"http://weijia-java.github.io/tags/Hexo/"}]}