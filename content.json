{"meta":{"title":"初白的BLOG","subtitle":"","description":"","author":"John Doe","url":"http://weijia-java.github.io","root":"/"},"pages":[{"title":"categories","date":"2020-12-23T15:09:29.000Z","updated":"2020-12-23T15:10:28.154Z","comments":true,"path":"categories/index.html","permalink":"http://weijia-java.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"MYSQL-01 | 基础架构：一条SQL查询语句是如何执行的？","slug":"MYSQL-01  基础架构：一条SQL查询语句是如何执行的？","date":"2020-12-24T09:48:39.000Z","updated":"2020-12-24T13:43:08.281Z","comments":true,"path":"2020/12/24/MYSQL-01  基础架构：一条SQL查询语句是如何执行的？/","link":"","permalink":"http://weijia-java.github.io/2020/12/24/MYSQL-01%20%20%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%EF%BC%9A%E4%B8%80%E6%9D%A1SQL%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84%EF%BC%9F/","excerpt":"","text":"MYSQL-01 | 基础架构：一条SQL查询语句是如何执行的？0 MYSQL慢查询​ 在web开发如此火爆的年代，数据库就成了我们开发中必不可少的一环。而使用数据库的绝大部分的时间是在单一的查询数据可，在大量的数据库查询中我们要尽可能的减少每一条的查询时间，而慢查询日志，就可以让我们在发现查询时间过长的SQL语句的时候对于查询为什么这么慢有很大帮助。 ​ 下面是MYSQL 慢查询日志：（一次性，永久的要修改my文件） 1234567891011121314151617181920212223242526272829-- 查看慢查询日志是否打开show variables like &#39;%slow%&#39; ;-- 查看慢查询状态show global status like &#39;%slow%&#39;; -- 打开慢查询日志set @@global.slow_query_log &#x3D; ON; -- 睡10s 测试慢查询select sleep(5) ; -- 查看慢查询超时时间show variables like &#39;long_query%&#39;-- 设置慢查询时间，超过这个时间则记录入慢查询日志set long_query_time&#x3D;2-- 查看慢查询日志输出方式select @@global.log_output -- 设置慢查询日志 table形式表示set @@global.log_output&#x3D;&#39;TABLE&#39;; -- 查询慢查询日志select * from mysql.slow_log; 1 基本结构​ 写这篇文章主要是想梳理一下MYSQL在执行一条SQL语句的时候发生的各种情况，MYSQL自己是怎么处理的。比如更新一条信息，根据（没有）主键查询信息。在以上的古城中数据库是怎样处理一下连带问题（权限，缓存，一致性，脏读和幻读的问题）。 ​ ​ 在MYSQL中一共可以大致的分成两层（不包括客户端）server层和存储引擎，而MYSQL的SQL语句主要是在server层进行处理。 ​ 在上图的可以看出，基本上分为server层和存储引擎两个部分。 ​ server层包括连接器、查询缓存（在8.0之后删除了）、分析器、优化器和执行器等，几乎包揽了MYSQL所有重要的核心功能，以及所有的内置函数。所有跨存储引擎的功能都在这一层实现，比如存储过程。触发器、视图等。 ​ 存储引擎负责数据的提取和存储功能。其架构是插件式（可更换），支持InnoDB、MyISAM、Memory等多个存储引擎，在MySQL 5.5.5版本开始默认InnoDB（在创建标时可以使用engine=Memory来使用你想要的存储引擎）。 1mysql&gt; select * from T where ID&#x3D;10； ​ 下面开始简单的解释一下上面的语句的执行流程。 2 连接器​ 在MySQL执行上面的数据前，首先要创建一个链接，来连接数据库，这个时候就是连接器来起作用。连接器主要负责和用户建立链接，获取权限，维持和管理连接。连接命令如下： 1mysql -h$ip -P$port -u$user -p -- 参数依次是数据库ip地址、端口号、用户名、密码 ​ 连接命令中的mysql是客户端工具，用来和服务端建立连接。在完成经典的TCP三次握手后，连接器开始验证身份。 如果用户名或密码错误，收到一个ACCESS DENIED FOR USER 的错误。 如果验证通过，连接器首先会去权限表查找你当前用户所持有的权限。之后的所有操作都依赖与这一次的权限查询。这也就意味着在当前连接没断开或者重新连接之前，管理员怎么修改当前用户的权限都不会起到效果，修改权限之后，只有在下一次连接时才会生效 连接完成后如，如果你没有后续的动作，这个连接就处于空闲状态，你可以使用show processlist命令看到它，其中sleep表示连接在空闲状态 ​ 如果空闲时间超过wait_timeout(最大空闲时间，默认值8小时)，自动断开连接。当断开连接后再去查询操作会返回LOST CONNECTION TO MYSQL SERVER DURING QUERY , 这时间你就需要重新连接，在执行当前请求了。 1mysql&gt; show variables like &#39;wait_timeout&#39;; 长短连接​ 数据库中，长连接是连接成功后，执行几个请求后，还继续长时间保持这个连接，下一个请求继续使用。短连接是连接成功后，在执行几个查询之后就断开连接，下一个查询新建一个连接。 ​ 由于数据库中建立连接的过程非常浪费时间，所以建议使用长连接，减少短连接的使用。但由于大量使用长连接有时候会导致MySQL占用内存会越来越快，这是因为MySQL在执行过程中使用的内存是管理在连接对象里面的，这些资源会在连接断开的时候释放。长连接积累下来，导致内存占用过大，被系统前置杀掉（OOM），从现象看就是MySQL异常重启。 ​ 解决上面的问题你可以用以下的两种方案： 定期断开长连接。使用一段时间，或者程序里面判断一个占用内存过比较大的操作后，断开连接，之后查询重连。 在MySQL 5.7或之后的版本中，你可以每次执行一个比较大的操作后使用mysql_reset_connection来初始化连接资源。这个过程不需要重连和重新做权限验证，但可以恢复到连接刚刚建立时的状态。 3 查询缓存​ 在连接上服务端之后，我们就来到了查询缓存。MySQL拿到一个查询语句后，先查询缓存中是否崔在。MySQL会把之前执行的SQL语句和结果以key-value对的形式直接缓存到内存中。key是之前查询的整个SQL语句，而value是查询结果。若果缓存命中直接返回给客户端。 ​ 如果未命中，则继续后面的分析，优化和执行阶段，执行结果会保存到缓存中。 ​ 但大多数情况下建议不要使用缓存，因为缓存命中率极低，并且还要占据内存。 ​ 查询缓存的命中率非常低，只要一个表进行了更新操作，这个表上的所有查询缓存都会被清空。因此可能刚刚把上一条执行结果缓存进去，马上该表就发生了更新导致缓存丢失。对于一个更新压力大的数据库，查询缓存命中率极低。除非你是一个静态表或者更新操作极少的表（系统配置表）。 ​ MySQL提供了按照需要是否使用缓存。可以将参数query_cache_type设置成DEMAND，这种模式下SQL语句不会使用查询缓存。对于使用查询缓存的语句，可以使用SQL_CACHE显示指定。如下： 1mysql&gt; select SQL_CACHE * from T where ID&#x3D;10； ​ 注：查询缓存在 MySQL 8.0 版本直接删除了，没有查询缓存这个功能了。 ​ 注：查询缓存命中返回结果前，会进行权限查询，判断当前用户是否有对这个表操作的权限。 ​ 4 分析器​ 如果没有命中查询缓存，就开始真正的执行语句了。首先MySQL需要知道你要做什么，因此需要对SQL语句进行“词法分析”。你输入的是由多个字符串和空格组成的SQL语句，MySQL需要识别出里面的字符串的含义。 ​ MySQL从你输入的“SELECT”关键字识别出，这是一个查询语句。它也要把字符串“T”识别成“表名T”，把字符串“ID”识别成“列ID”。 ​ 做完这些识别后，还要做的就是语法分析。根据上面词法分析的结果，语法分析会语法规则，判断你输入的这个SQL语句是否满足MySQL语法。如果语句错误，会给你返回YOU HAVE AN ERROR IN YOU SQL SYNTAX的错误提醒，如下： 1234mysql&gt; elect * from t where ID&#x3D;1;ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;elect * from t where ID&#x3D;1&#39; at line 1 5 优化器​ 经过了分析器，MySQL就知道你要做什么了。在开始执行之前，还要经过优化器的处理。 ​ 优化器是在表里面有多个索引的时候，决定使用哪个索引，或者在一个语句有多表关联的时候，决定各个表的连接顺序。比如你执行下面这样的语句，这个语句是执行两个表的join： 1mysql&gt; select * from t1 join t2 using(ID) where t1.c&#x3D;10 and t2.d&#x3D;20; 既可以先从t1里面取出c=10的记录ID值，在根据ID值关联到t2，再判断t2里面的d是否等于20。 也可以先从t2里面取出d=20的记录ID值，再根据ID值关联到t1，再判断t1里面的c是否等于10。 ​ 两种执行方法的结果一样，但执行所需要的时间是不同的，而优化器的作用就是决定使用哪一个方案。优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。 6 执行器​ 开始执行的时候要判断当前用户是否对这个表拥有权限，如果没有则返回无权限错误。 123mysql&gt; select * from T where ID&#x3D;10;ERROR 1142 (42000): SELECT command denied to user &#39;b&#39;@&#39;localhost&#39; for table &#39;T&#39; ​ 有权限，就打开表继续执行。打开表的时候执行器会根据引擎定义，去使用引擎提供的接口。 ​ 在无索引的情况下会一行一行的进行对比查找结果，存在索引的情况下，会在索引树上一层一层的进行对比。 7 注如果表中没有字段K，而你执行了这个语句select * from T where k=1肯定会报错：“Unknown column k in where clause”，这个错误是在分析器上给出的。","categories":[{"name":"MYSQL_深度解析","slug":"MYSQL-深度解析","permalink":"http://weijia-java.github.io/categories/MYSQL-%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/"}],"tags":[{"name":"MYSQL","slug":"MYSQL","permalink":"http://weijia-java.github.io/tags/MYSQL/"}]},{"title":"My New Post","slug":"My-New-Post","date":"2020-12-22T12:41:26.000Z","updated":"2020-12-24T03:03:09.176Z","comments":true,"path":"2020/12/22/My-New-Post/","link":"","permalink":"http://weijia-java.github.io/2020/12/22/My-New-Post/","excerpt":"","text":"Hexo文章初步建设 新建文章命令 hexo new post postname 文章生成目录存在于blog/scourse/ win、IOS系统使用markdown软件打开编辑，命令行使用vim 文章生成 hexo g 文章发布 hexo d","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://weijia-java.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://weijia-java.github.io/tags/Hexo/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-12-22T10:22:36.215Z","updated":"2020-12-22T10:22:36.215Z","comments":true,"path":"2020/12/22/hello-world/","link":"","permalink":"http://weijia-java.github.io/2020/12/22/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"MYSQL_深度解析","slug":"MYSQL-深度解析","permalink":"http://weijia-java.github.io/categories/MYSQL-%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/"},{"name":"Hexo","slug":"Hexo","permalink":"http://weijia-java.github.io/categories/Hexo/"}],"tags":[{"name":"MYSQL","slug":"MYSQL","permalink":"http://weijia-java.github.io/tags/MYSQL/"},{"name":"Hexo","slug":"Hexo","permalink":"http://weijia-java.github.io/tags/Hexo/"}]}